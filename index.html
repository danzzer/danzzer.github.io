
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Danzzer&#39;s Blog">
    <title>Danzzer&#39;s Blog</title>
    <meta name="author" content="Danzzer">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="My thoughts here">
<meta property="og:type" content="blog">
<meta property="og:title" content="Danzzer's Blog">
<meta property="og:url" content="http://danzzer.github.io/index.html">
<meta property="og:site_name" content="Danzzer's Blog">
<meta property="og:description" content="My thoughts here">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Danzzer's Blog">
<meta name="twitter:description" content="My thoughts here">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-ejlztp1tasruqfvoz6xmgqng0anzae8ox7cqjj5yibieqgcmhe9fwxfae6zj.min.css" type="text/css">
    <!--STYLES END-->
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73358727-1', 'auto');
  ga('send', 'pageview');

</script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">Danzzer&#39;s Blog</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="/#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="/#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">搜索</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/danzzer" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://stackoverflow.com/users/4683285/danzeer" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
                    <span class="sidebar-button-desc">Stack Overflow</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/03/11/Nginx-Location匹配规则/">
                            Nginx Location匹配规则
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Fri Mar 11 2016 14:53:49 GMT+0800">
	
		    3月 11, 2016
    	
    </time>
    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="Location_u8BED_u6CD5_u89C4_u5219"><a href="#Location_u8BED_u6CD5_u89C4_u5219" class="headerlink" title="Location语法规则"></a>Location语法规则</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">optional_modifier</span> location_match &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<font style="color:red">location_match</font>为URI匹配字符串</p>
<p>optional_modifier:</p>
<ul>
<li>(none): 无修饰则为前缀匹配</li>
<li>=     : 前缀完全匹配, 即/path只匹配/path/单一目录的访问</li>
<li>~ : 正则匹配，且大小写敏感</li>
<li>~* : 正则匹配，且大小不敏感</li>
<li>^~ : 前缀匹配，且如果匹配则不再进行正则匹配</li>
</ul>
<h2 id="Location_u5339_u914D_u987A_u5E8F"><a href="#Location_u5339_u914D_u987A_u5E8F" class="headerlink" title="Location匹配顺序"></a>Location匹配顺序</h2><p>A. 先进行前缀匹配(非正则匹配)</p>
<pre><code>1. 对=进行前缀完全匹配，如果有匹配则使用该规则且停止匹配
2. 如果没有=匹配且存在^~的匹配则使用该规则且停止匹配
3. 如果(none)匹配则先缓存该匹配
</code></pre><p>B. 进行正则匹配，按照书写顺序第一个满足的将被使用且停止匹配<br>C. 如果A3有匹配则使用该规则<br>D. 无匹配则4XX</p>
<h2 id="u6765_u6E90Blog"><a href="#u6765_u6E90Blog" class="headerlink" title="来源Blog"></a>来源Blog</h2><p>digitalocean上的此篇<a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms" target="_blank" rel="external">Blog</a>不错，推荐下</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/03/11/Nginx-Location匹配规则/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/23/字符串首字母UpperCase/">
                            字符串首字母UpperCase
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Tue Feb 23 2016 21:00:28 GMT+0800">
	
		    2月 23, 2016
    	
    </time>
    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>这个题目估计大家都知道要用split去做分割然后替换首字母</p>
<p>但是比如 var strName ＝ “a b c”可以简单分割后处理，but 如果是 strName ＝ ”a   b，?c”呢？</p>
<p>so除了考察下split和基本字符串操作（你当然会比较+ 和 join的区别咯，不知道的可以趁机google下）,貌似并不实用. 其实正则写法挺简单的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'aaa ?bbb ,ccc'</span>;</span><br><span class="line"><span class="keyword">var</span> uw=name.replace(<span class="regexp">/\b\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> word.toUpperCase()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(uw)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>\b是单词的开头或者结尾匹配， 而且toUpperCase只对字母有效</p>
</blockquote>
<p>嗯，感觉吊吊的</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/02/23/字符串首字母UpperCase/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/16/使用Promise合理处理模块封装和数据的关系/">
                            使用Promise合理处理模块封装和数据的关系
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Tue Feb 16 2016 14:23:19 GMT+0800">
	
		    2月 16, 2016
    	
    </time>
    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="u6570_u636E_u5230_u5C55_u73B0_u7684_u8FC7_u7A0B"><a href="#u6570_u636E_u5230_u5C55_u73B0_u7684_u8FC7_u7A0B" class="headerlink" title="数据到展现的过程"></a>数据到展现的过程</h2><p>对Javascript代码做模块封装时一般都会在数据处理过程如何拆分上纠缠很久,<br>主要需要考虑<font color="green">‘view的通用性’</font>和<font color="green">‘data源的多样性’</font>如何结合. </p>
<p>抽象data-&gt;view的过程如下(MV*都需要手工编码这个过程):</p>
<ol>
<li>获取数据源(url)</li>
<li>从数据源获取数据后,配适数据为view需要的格式</li>
<li>view展现数据</li>
</ol>
<p>结合以上过程解释下:</p>
<ul>
<li>view的通用性: 第3过程基本编码后能够在不修改的情况下在其他编码中使用,提高代码复用程度</li>
<li>data源的多样性: 数据源可能有不同, 相同数据可能需要为不同view配适</li>
</ul>
<h2 id="u66FE_u7ECF_u7684_u8FC7_u7A0B_u5316_u7F16_u7801"><a href="#u66FE_u7ECF_u7684_u8FC7_u7A0B_u5316_u7F16_u7801" class="headerlink" title="曾经的过程化编码"></a>曾经的过程化编码</h2><p>独立开发或者维护的时候经常会出现一批如下不能复用的代码, 主要原因大概是写的时候有个念头-“这个代码过程只会在这里用”,当然结局都是填坑比挖坑还累</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码,不是jquery</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line"> <span class="comment">//1. 获取数据源 </span></span><br><span class="line"> url:<span class="string">"url"</span>, </span><br><span class="line"> queryCondition: &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//这里假设data已经转化为object</span></span><br><span class="line">     <span class="comment">//2. parse数据</span></span><br><span class="line">     <span class="keyword">var</span> displayData = &#123;</span><br><span class="line">         name: data.othername</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//3. view展现数据</span></span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">"view"</span>).innerHtml(...)</span><br><span class="line"> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="u600E_u4E48_u590D_u7528_3F"><a href="#u600E_u4E48_u590D_u7528_3F" class="headerlink" title="怎么复用?"></a>怎么复用?</h2><p>以上过程化代码存在如下问题</p>
<ol>
<li>对于异步请求处理, 使用了callback写法, callback hell 不可避免, 需要使用Promise解决.<a href="http://callbackhell.com/" target="_blank" rel="external">问题参考</a>, <a href="https://www.phodal.com/blog/javascript-promise/" target="_blank" rel="external">中文的</a></li>
<li>对于url,parse,view 的需求变化需要hard code, 必须做封装</li>
</ol>
<p>为了封装 “获取数据源”, 我曾经这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSource = [&#123;</span><br><span class="line">     url: <span class="string">"abc"</span>,</span><br><span class="line">     queryCondition,</span><br><span class="line">     ....</span><br><span class="line"> &#125;]</span><br><span class="line"> .....</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">dataFetchFactory</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> $.promisedAjax(&#123;</span><br><span class="line">         url: source.url,</span><br><span class="line">         queryCondition: source.queryCondition</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> .....</span><br><span class="line"> <span class="keyword">var</span> handleData = dataFetchFactory(dataSource[<span class="number">0</span>])</span><br><span class="line"> handle.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> displayData = &#123;</span><br><span class="line">         name: data.othername</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">"view"</span>).innerHtml(...)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>虽然’获取数据源’ 被封装成了类似工厂的用法,但是工厂函数内依然逻辑结构上耦合了数据源的数据结构, 如果dataSource修改了那么factory的函数也必须修改;同时依然不能处理多个parse的需求</p>
<p>近期改写过程如下,此方案还是需要深入思考和修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.promise直接视为数据源,不再需要factory, 不同数据源只需要创建不同的promise</span></span><br><span class="line"><span class="comment">//如果需要错误处理,则在$.promisedAjax上再包装一层promise</span></span><br><span class="line"><span class="keyword">var</span> dataSource = [</span><br><span class="line">     $.promisedAjax(&#123;</span><br><span class="line">         url: source.url,</span><br><span class="line">         queryCondition: source.queryCondition</span><br><span class="line">     &#125;)</span><br><span class="line">]</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//2. 为了处理parse的不同需求问题,需要不同的parser</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> parser1 = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123; name: data.othername &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parser2 = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//满足相同data的不同parse需求</span></span><br><span class="line">     <span class="keyword">return</span> &#123; 名字: data.othername&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parse3 = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//不同data的parse</span></span><br><span class="line">     <span class="keyword">return</span> &#123; name: data.cutename &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parser 也可以考虑promise化</span></span><br><span class="line"><span class="keyword">var</span> parsePromise = <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> deferred = Q()</span><br><span class="line">     promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> data = &#123; name: data.cutename &#125;</span><br><span class="line">         deferred.resolve(data)</span><br><span class="line">     &#125;)</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> deffered.promise</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//3. model到view过程已经有很多的框架或者既有写法了,不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">"view"</span>).innerHtml(...)</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 在代码中复用以上的代码</span></span><br><span class="line"></span><br><span class="line">dataSource[<span class="number">0</span>].then(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">     display(parser1(d))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果parser 也promise化, 那么看起来如下, 有点自解释的感觉</span></span><br><span class="line">dataSource[<span class="number">0</span>]</span><br><span class="line"> .then(parsePromise)</span><br><span class="line"> .then(display)</span><br></pre></td></tr></table></figure>
<p>三者之间除了2和3在最终数据格式上有逻辑规约,其他没有耦合;即使逻辑规约改变了, parser和display的替换都比hardcode 方便</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>注意promise 除了很好避免了callback hell, 同时更可贵的是在抽象层面上将”过程”很好的封装, 假设所有中间过程的处理结果都是promise化,那么代码能够很清晰反应逻辑顺序</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语言有时候很无力,看下面你大概就知道了</span></span><br><span class="line"><span class="tag">var</span> begin = <span class="function"><span class="title">A</span><span class="params">()</span></span></span><br><span class="line">begin.<span class="function"><span class="title">then</span><span class="params">(B)</span></span>.<span class="function"><span class="title">then</span><span class="params">(C)</span></span>.....</span><br></pre></td></tr></table></figure>
                    
                        

                    
                    
                        <p>
                            <a href="/2016/02/16/使用Promise合理处理模块封装和数据的关系/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/02/04/web加载性能/">
                            web加载性能
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Thu Feb 04 2016 16:48:24 GMT+0800">
	
		    2月 04, 2016
    	
    </time>
    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="DOM_u548C_u9875_u9762_u5185_u5BB9_u57FA_u672C_u7279_u5F81"><a href="#DOM_u548C_u9875_u9762_u5185_u5BB9_u57FA_u672C_u7279_u5F81" class="headerlink" title="DOM和页面内容基本特征"></a>DOM和页面内容基本特征</h2><ol>
<li><p>HTML parse 为DOM的过程（初步的Layout）不受页面内标签影响</p>
</li>
<li><p>‘同步’的script的加载会阻塞所有(没有优化的情况下)后续资源的加载;css由于不会修改DOM加载都是并行的, 但是可能阻塞‘同时’访问对应属性的script</p>
</li>
</ol>
<p>以下引用<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="external">参考blog</a>详细描述, 注意有颜色部分：</p>
<blockquote>
<p>The order of processing scripts and style sheets</p>
<p>Scripts</p>
<p>The model of the web is <font color="green">synchronous</font>. Authors expect scripts to be parsed and executed immediately when the parser reaches a script tag. <font color="green">The parsing of the document halts until the script was executed</font>. If the script is external then the resource must be first fetched from the network - this is also done synchronously, <font color="green">the parsing halts until the resource is fetched</font>. This was the model for many years and is also specified in HTML 4 and 5 specifications. Authors could mark the script as <font color="blue">“defer”</font> and thus it will not halt the document parsing and will execute <font color="blue">after it is parsed</font>. HTML5 adds an option to mark the script as asynchronous so it will be parsed and <font color="blue">executed by a different thread</font>.</p>
</blockquote>
<p>注意：script的defer是在dom的parse完成后再执行，async是异步(不同现成)并行执行，这里应该解释的很清晰了</p>
<blockquote>
<p>Speculative parsing(部分浏览器内核的优化)</p>
<p>Both Webkit and Firefox do this optimization. While executing scripts, <font color="green">another thread</font> <font color="red">parses</font> the rest of the document and finds out what other resources need to be loaded from the network and loads them. These way resources can be loaded on parallel connections and the overall speed is better. Note - <font color="blue">the speculative parser doesn’t modify the DOM tree and leaves that to the main parser</font>, it <font color="red">only parses</font> references to external resources like external scripts, style sheets and images.</p>
</blockquote>
<p>注意：另外的线程仅仅是‘parse document’（html-&gt;DOM）和‘加载’(network),由于涉及到DOM,javascript的执行过程还是在main parser(UI thread!)中的</p>
<blockquote>
<p>Style sheets</p>
<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, <font color="green">there is no reason to wait for them and stop the document parsing</font>. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. Webkit blocks scripts only when they try to access for certain style properties that may be effected by unloaded style sheets.</p>
</blockquote>
<p>注意：javascript对css中的属性有依赖时候可能导致的问题</p>
<h2 id="u9875_u9762_u52A0_u8F7D_u6162_u7684_u4E00_u4E9B_u539F_u56E0_u63A2_u5BFB"><a href="#u9875_u9762_u52A0_u8F7D_u6162_u7684_u4E00_u4E9B_u539F_u56E0_u63A2_u5BFB" class="headerlink" title="页面加载慢的一些原因探寻"></a>页面加载慢的一些原因探寻</h2><p>结合目前的一些已有的<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">tips(from yahoo)</a>，将按照以下层次探索加载的问题和解决策略</p>
<ol>
<li>网络通信建立</li>
<li>HTTP请求头部,内容大小,传输速率,并发和逻辑依赖</li>
<li>用户体验和心理</li>
</ol>
<h3 id="u7F51_u7EDC_u901A_u4FE1_u5EFA_u7ACB"><a href="#u7F51_u7EDC_u901A_u4FE1_u5EFA_u7ACB" class="headerlink" title="网络通信建立"></a>网络通信建立</h3><p>HTTP由于基于TCP/IP stack存在基本socket通信的一些问题</p>
<ol>
<li><p>URL到IP的DNS解析需要消耗时间（20-120ms）</p>
<blockquote>
<p>Server DNS的TTL是一个很小的影响因素，主要是client的浏览器和系统中的缓存时间过小会频繁做DNS解析，引用雅虎的做法如下（可能目前大部分浏览器都已经自动优化了）：</p>
<p>Internet Explorer caches DNS lookups for 30 minutes by default, as specified by the DnsCacheTimeout registry setting. Firefox caches DNS lookups for 1 minute, controlled by the network.dnsCacheExpiration configuration setting. (Fasterfox changes this to 1 hour.)</p>
</blockquote>
</li>
<li><p>socket的建立和销毁需要时间</p>
<blockquote>
<p>如果每个资源的获取都要和不同IP建立socket，那么client的系统中会有socket的资源创建过程，必然会耗费一定的时间；socket销毁时也会有TIME-WAIT状态（等待足够的时间以确保远程TCP接收到连接中断请求的确认）导致资源的暂时不可用；如果资源能够策略性通过有限的socket（socket会被复用）获取可以减少此部分的消耗</p>
</blockquote>
</li>
<li><p>IP报文的拆分和合并，主要影响信息利用率，对HTTP的影响可以忽略</p>
<blockquote>
<p>以太网的MTU是1500字（由于IPv6的发展，目前网络情况是可能支持巨大包传输的，依赖ISP的实施情况，这里还是基于基础IPv4网络通识解释）,由于此限制 IP层报文过大时会被网络设备自动拆包分组传输，会影响传输效率，但是时间消耗（当前国内网络设备的影响都是毫秒级的）可以被忽视</p>
</blockquote>
</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ol>
<li><p>HTTP （目前常用1.1）协议是无状态协议，那么在一个请求中为了区分客户端状态会附加cookies，如果所有请求都统一cookie那么会造成浪费；各个浏览器可能限制cookies最多4KB以内， 按照目前的网络条件可能是一个微小的改进项</p>
</li>
<li><p>Yahoo指出AJAX（XMLHttpRequest）请求方式GET 和 POST 在浏览器上实现不同， 大多数POST都需要俩个TCP报文，GET只有一个；在都能满足需求的基础上，选择GET是减少通信时间的方式（注意是AJAX的GET和POST), <a href="https://josephscott.org/archives/2009/08/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="external">相关内容</a></p>
</li>
<li><p>HTTP中文件和内容大小是我们容易想到的因素，对于图片和文本文件我们可以寻找对应压缩方法，这是工作中经常会处理的</p>
</li>
</ol>
<blockquote>
<p>图片压缩方法有很多：css sprite做图片合并（复用颜色）同时使用background引用图片）， 使用无损的webfont代替较大的位图，使用webq图片压缩….当然新技术可能会有兼容性问题，<font color="gree">css的base64并不是图片压缩，只是提前了图片渲染的时序</font></p>
<p>css压缩： 工具化去掉空格和换行，尽量少地写css, 多css文件合并（这个是为了尽快加载所有css）等</p>
<p>js压缩：基本都是使用uglify.js做混淆（人不可读）和压缩空格和换行等</p>
<p>web服务器端支持gzip，一般开启后会有不错的效果</p>
</blockquote>
<ol>
<li><p>HTTP的传输速率上很自然会想到服务器带宽，同时CDN的使用可以在地域上部分加速</p>
</li>
<li><p>HTTP在浏览器中的‘对一个host的并发请求’和‘并发请求总数’是有限制的，<a href="http://www.browserscope.org/?category=network&amp;v=top" target="_blank" rel="external">参考来源</a>, 合理安排请求的host既可以在tcp层复用socket同时也能按照该特性充分使用并发的限制</p>
</li>
</ol>
<blockquote>
<p>如果浏览器限制对一个host最多有5个并发请求，总并发请求不超过10。那么同等网络条件下（无限带宽和资源），对一个host请求10个文件将比对两个host分别请求5个文件要慢</p>
<p>因此使用cdn的时候可以设置多个domain（多host）来应用以上的技巧</p>
</blockquote>
<ol>
<li>实际使用中通常会看到javascript通过添加script来加载动态的脚本引用，该引用脚本将对DOM的一些样式属性或者DOM做操作，那么这些DOM的样式在脚本执行完成前对于用户来说将是未完成的显示样式（前端MV*的框架一般可能空白一会!）</li>
</ol>
<blockquote>
<p>一般不在javascript中做dom的操作是应为相对很慢</p>
</blockquote>
<h3 id="u7528_u6237_u4F53_u9A8C"><a href="#u7528_u6237_u4F53_u9A8C" class="headerlink" title="用户体验"></a>用户体验</h3><p>页面的加载性能和用户‘快速’体验不是同等的概念：加载只是针对资源，而用户看到的只是浏览器可视区域的内容，注意用户需要的是他们眼里的：</p>
<ol>
<li>快速：开了页面就能看到东西，虽然用户并不知道那是什么，但是他知道这个页面在运行，并且有基本信息可以阅读</li>
</ol>
<blockquote>
<p>某些时候mobile环境下网速&lt;5KB,感觉一切都是白费的</p>
</blockquote>
<p>很自然的我们可以：</p>
<ol>
<li>在html内的style内使用css做缓冲动画（比如旋转的各种图标）, 真实的内容渲染时再去掉它，那么用户第一眼感觉上是这个图片在加载</li>
<li>对于图片这种大文件可以使用 lowsrc做图片预载（先使用模糊小图片，后用完全尺寸替换), 可以使用默认占位的图片或者背景色</li>
<li>由于用户看到的是可视区域内的内容，那么可视区域外的图片（貌似也只能对图片）可以做懒加载（判断是否在window.innerXXX范围内）或者延迟加载（使用settimeout延迟加载资源）</li>
</ol>
<blockquote>
<p>懒加载 需要在window的一些事件中对图片遍历判断是否开始出现在可视区域（对的你得自己维护一个或者多个队列），具体做法请参考<a href="http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433" target="_blank" rel="external">这里</a>，开始出现时再通过javascript加载</p>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>目前只想到这么多，好的想法请Pull request</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/02/04/web加载性能/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/01/16/react-router-快速印象/">
                            react-router 快速印象
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" content="Sat Jan 16 2016 16:23:50 GMT+0800">
	
		    1月 16, 2016
    	
    </time>
    
</div>
            </div>
            
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p><a href="https://github.com/rackt/react-router" target="_blank" rel="external">react-router 的git</a></p>
<h2 id="react-router__u57FA_u672C_u4F7F_u7528"><a href="#react-router__u57FA_u672C_u4F7F_u7528" class="headerlink" title="react-router 基本使用"></a>react-router 基本使用</h2><p>使用方式，直接看最底部Router的配置：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import React <span class="keyword">from</span> 'react'</span><br><span class="line">import &#123; render &#125; <span class="keyword">from</span> 'react-dom'</span><br><span class="line">import &#123; Router, Route, Link, browserHistory &#125; <span class="keyword">from</span> 'react-router'</span><br><span class="line"></span><br><span class="line">const App = React.createClass(&#123;/*...*/&#125;)</span><br><span class="line">const About = React.createClass(&#123;/*...*/&#125;)</span><br><span class="line">// etc.</span><br><span class="line"></span><br><span class="line">const Users = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="variable">&lt;div&gt;</span></span><br><span class="line">        <span class="variable">&lt;h1&gt;</span>Users<span class="variable">&lt;/h1&gt;</span></span><br><span class="line">        <span class="variable">&lt;div className="master"&gt;</span></span><br><span class="line">          <span class="variable">&lt;ul&gt;</span></span><br><span class="line">            &#123;/* use Link <span class="keyword">to</span> route around the app */&#125;</span><br><span class="line">            &#123;this.<span class="keyword">state</span>.users.map(<span class="keyword">user</span> =&gt; (</span><br><span class="line">              <span class="variable">&lt;li key=&#123;user.id&#125;&gt;</span><span class="variable">&lt;Link to=&#123;`/user/$&#123;user.id&#125;`&#125;&gt;</span>&#123;<span class="keyword">user</span>.name&#125;<span class="variable">&lt;/Link&gt;</span><span class="variable">&lt;/li&gt;</span></span><br><span class="line">            ))&#125;</span><br><span class="line">          <span class="variable">&lt;/ul&gt;</span></span><br><span class="line">        <span class="variable">&lt;/div&gt;</span></span><br><span class="line">        <span class="variable">&lt;div className="detail"&gt;</span></span><br><span class="line">          &#123;this.props.children&#125;</span><br><span class="line">        <span class="variable">&lt;/div&gt;</span></span><br><span class="line">      <span class="variable">&lt;/div&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const User = React.createClass(&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">      // route components are rendered with useful information, like URL params</span><br><span class="line">      <span class="keyword">user</span>: findUserById(this.props.params.<span class="keyword">user</span>Id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="variable">&lt;div&gt;</span></span><br><span class="line">        <span class="variable">&lt;h2&gt;</span>&#123;this.<span class="keyword">state</span>.<span class="keyword">user</span>.name&#125;<span class="variable">&lt;/h2&gt;</span></span><br><span class="line">        &#123;/* etc. */&#125;</span><br><span class="line">      <span class="variable">&lt;/div&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Declarative route configuration (could also <span class="built_in">load</span> this config lazily</span><br><span class="line">// instead, <span class="literal">all</span> you really need is a single root route, you don't need <span class="keyword">to</span></span><br><span class="line">// colocate the entire config).</span><br><span class="line">render((</span><br><span class="line">  <span class="variable">&lt;Router history=&#123;browserHistory&#125;&gt;</span></span><br><span class="line">    <span class="variable">&lt;Route path="/" component=&#123;App&#125;&gt;</span></span><br><span class="line">      <span class="variable">&lt;Route path="about" component=&#123;About&#125;/&gt;</span></span><br><span class="line">      <span class="variable">&lt;Route path="users" component=&#123;Users&#125;&gt;</span></span><br><span class="line">        <span class="variable">&lt;Route path="/user/:userId" component=&#123;User&#125;/&gt;</span></span><br><span class="line">      <span class="variable">&lt;/Route&gt;</span></span><br><span class="line">      <span class="variable">&lt;Route path="*" component=&#123;NoMatch&#125;/&gt;</span></span><br><span class="line">    <span class="variable">&lt;/Route&gt;</span></span><br><span class="line">  <span class="variable">&lt;/Router&gt;</span></span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure>
<p>以上Users中通过<link> 访问不同User, 注意Users中显示写了 this.props.children 用于User的更新。</p>
<p>关键词： Router， Route， LINK</p>
<p>NOTE: </p>
<ol>
<li><p>react-router只能是“层级嵌套”的view层级， 这意味着整体替换（比如APP整体结构都变了） 的层级变化是不能实现的 </p>
</li>
<li><p>注意到component是没有带自定义参数的（目前没有搜索到），只能通过path携带， 这么一来。。。。好像不灵活了</p>
</li>
<li><p>LINK不是单纯a标签，跳转是有限制的</p>
</li>
<li><p>router 实际需要操作history ，注意 Router中的history 属性绑定</p>
</li>
</ol>
<h2 id="u914D_u5408wepack_u5B9E_u73B0_u5F02_u6B65_u52A0_u8F7Dmodule"><a href="#u914D_u5408wepack_u5B9E_u73B0_u5F02_u6B65_u52A0_u8F7Dmodule" class="headerlink" title="配合wepack实现异步加载module"></a>配合wepack实现异步加载module</h2><p>router的example中的huge-apps 是一个异步加载module的示例， 主要是通过cmd的加载语法require.ensure 让webpack自动分开打包文件。</p>
<p>此项目文档很呵呵， 异步加载实际需要使用Router中的route属性，但是文档中找不到， 以下是过程的一个简写示例， 只看 rootRoute 即可</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; from <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createHistory, useBasename &#125; from <span class="string">'history'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; from <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">import</span> stubbedCourses from <span class="string">'./stubs/COURSES'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = useBasename(createHistory)(&#123;</span><br><span class="line">  basename: <span class="string">'/huge-apps'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootRoute = &#123;</span><br><span class="line">  component: <span class="string">'div'</span>,</span><br><span class="line">  childRoutes: [ &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    component: <span class="built_in">require</span>(<span class="string">'./components/App'</span>),</span><br><span class="line">    childRoutes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'calendar'</span>,</span><br><span class="line">        getComponent(location, cb) &#123;</span><br><span class="line">          <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">            cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./routes/Calendar/components/Calendar'</span>))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//后面这些实际都是对模块定义了path 和 getComponent方法（使用CMD的require.ensure加载， 加载时会映射到webpack对应的增量包）</span></span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'./routes/Course'</span>),</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'./routes/Grades'</span>),</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'./routes/Messages'</span>),</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'./routes/Profile'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;history&#125; routes=&#123;rootRoute&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="u503C_u5F97_u501F_u9274_u7684_u5730_u65B9"><a href="#u503C_u5F97_u501F_u9274_u7684_u5730_u65B9" class="headerlink" title="值得借鉴的地方"></a>值得借鉴的地方</h2><ol>
<li><p>webpack中实现了写入到内存的的方式（webpackDevMiddleware中间件定向到内存， webpack中的output需要定义好规则），同样使用watch检测修改自动映射， 这可能比在“开发”时候 写code在src， 启动服务器在build下更好一点； build和src存在的一个问题是，容易在修改时候访问到不同文件夹的同名文件，频繁的话是比较恶心的，这个根据每个人的情况而定； 对于发布来说，放在内存比文件响应是要快一些的，同时webpack的过程放在了server.js中，发布也只需要执行一个命令（build 可能需要先build命令，然后执行启动命令）</p>
</li>
<li><p>webpack使用了code splitting 方式（之前的CMD require写法）， 同时通过wepack 配置插件webpack.optimize.CommonsChunkPlugin(‘shared.js’)，自动提取了页面公用部分</p>
</li>
</ol>
<h2 id="u9AD8_u7EA7_u4F7F_u7528_u90E8_u5206_u8BF7_u81EA_u884C_u53C2_u770Bgithub_u4E2D_u6587_u6863"><a href="#u9AD8_u7EA7_u4F7F_u7528_u90E8_u5206_u8BF7_u81EA_u884C_u53C2_u770Bgithub_u4E2D_u6587_u6863" class="headerlink" title="高级使用部分请自行参看github中文档"></a>高级使用部分请自行参看github中文档</h2><h2 id="redux_u8BA4_u4E3A_u6BD4_u8F83_u91CD_u8981_u7684_u60F3_u6CD5"><a href="#redux_u8BA4_u4E3A_u6BD4_u8F83_u91CD_u8981_u7684_u60F3_u6CD5" class="headerlink" title="redux认为比较重要的想法"></a>redux认为比较重要的想法</h2><p><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.l3aljox8v" target="_blank" rel="external">Presentational and Container Components</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2016/01/16/react-router-快速印象/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2016 Danzzer. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Danzzer</h4>
        
            <h5 id="about-card-bio"><p>贪心的码农</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>代码来者不拒</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/scrip-gfmrkxcl0qohe3cfdgxhzvc0yrceqta8i4iix0txvn8q4o2adlqd5n0jmkvt.min.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
